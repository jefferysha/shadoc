# 04 事件处理与交互 (深度解析版)

## 0. 语法预热 (Prerequisites)

### 0.1 高阶函数 (Higher-Order Function) 与回调
JS 中函数是一等公民，可以像变量一样传递。
*   **回调函数 (Callback)**: 你定义一个函数，传给别人（比如浏览器或子组件），等事情发生时，别人调用你的函数。

```javascript
// 这里的 () => console.log('Hi') 就是回调函数
// 我们把它传给了 button 的 onClick 属性
const handleClick = () => console.log('Hi');
<button onClick={handleClick}>Click</button> // 注意：不能写成 handleClick()，那样会立即执行！
```

### 0.2 TS 类型断言与联合类型

*   **联合类型 (Union Types)**: `TypeA | TypeB`，表示可能是 A 也可能是 B。
*   **泛型事件类型**: `React.MouseEvent<T>`，T 代表触发事件的 HTML 元素类型。

### 0.3 事件流：冒泡 (Bubbling) 与 捕获 (Capturing)
当你点击一个按钮时，浏览器并不是只告诉按钮“你被点了”，而是走一个“U型”流程：
1.  **捕获阶段**: Window -> Document -> Body -> ... -> Button (从上往下传)
2.  **目标阶段**: Button
3.  **冒泡阶段**: Button -> ... -> Body -> Document -> Window (从下往上传)

**默认情况下**，`onClick` 只监听**冒泡阶段**。如果你想监听捕获阶段，用 `onClickCapture`。

---

## 1. React 事件系统：合成事件 (SyntheticEvent)

React 的事件（如 `onClick`）**不是**浏览器的原生事件。

### 1.1 为什么不直接用原生事件？
1.  **跨浏览器兼容**: React 帮你抹平了 IE、Chrome、Safari 的差异。你总是能从 `event` 对象里拿到一样的东西。
2.  **性能优化 (事件委托)**:
    *   **原理**: 假设你有 1000 个 `<li>`，给每个都绑一个 `onclick` 会导致浏览器内存爆炸。
    *   **React 做法**: 它只在根节点 (`#root`) 绑了一个监听器。当你在任何地方点击，事件冒泡到根节点，React 收到后，找那是哪一个组件触发的，然后调用你写的 `onClick` 函数。
    *   **React 17 的重大变更**: 以前绑定在 `document` 上，现在绑定在 `root` 容器上。这解决了“微前端”架构下，多个 React 应用共存时的事件冲突问题。

### 1.3 实战：冒泡的陷阱 (Modal 点击遮罩关闭)
一个经典案例：点击弹窗内容不关闭，点击背景遮罩才关闭。
```tsx
const Modal = ({ onClose }) => {
  return (
    <div 
      className="overlay" 
      onClick={onClose} // 点击遮罩 -> 关闭
      style={{ position: 'fixed', inset: 0, background: 'rgba(0,0,0,0.5)' }}
    >
      <div 
        className="content"
        // 【关键】阻止冒泡！否则点击内容 -> 冒泡到 overlay -> 触发 onClose
        onClick={(e) => e.stopPropagation()} 
        style={{ background: 'white', padding: 20 }}
      >
        Clicking here won't close it.
      </div>
    </div>
  );
};
```

### 1.2 代码逐行解析：基础绑定

```tsx
import React from 'react';

const Button = () => {
  // 定义事件处理函数
  // event 参数: 类型是 React.MouseEvent
  // HTMLButtonElement: 泛型，告诉 TS 这个事件是由 button 触发的
  const handleClick = (event: React.MouseEvent<HTMLButtonElement>) => {
    // 阻止默认行为（比如提交表单后刷新的默认动作）
    event.preventDefault();
    
    // 阻止冒泡（防止事件传给父组件）
    // 注意：在 React 中这阻止的是'合成事件'的冒泡
    event.stopPropagation();
    
    // event.target: 触发事件的元素
    console.log('Clicked!', event.target);
  };

  return (
    // 注意 onClick 是驼峰命名 (camelCase)
    // 传入的是 handleClick 函数引用，不是函数调用 result
    <button onClick={handleClick}>Click Me</button>
  );
};
```

---

## 2. 交互实战：拖拽 (Transfer API)

实现一个 HTML5 原生拖拽功能。

```tsx
import React, { useState } from 'react';

const DraggableBox = () => {
  // 状态：记录是否正在被拖拽
  const [isDragging, setIsDragging] = useState(false);

  // 1. 开始拖拽 (Drag Start)
  const handleDragStart = (e: React.DragEvent<HTMLDivElement>) => {
    setIsDragging(true); // 更新 UI 状态
    
    // DataTransfer API: 拖拽的数据载体
    // 必须设置数据，否则在该死的 Firefox 等浏览器上可能拖不动
    e.dataTransfer.setData('text/plain', '我是被拖拽的数据');
    // 设置拖拽时的鼠标效果 (move, copy, link)
    e.dataTransfer.effectAllowed = 'move';
  };

  // 2. 拖拽结束 (Drag End)
  const handleDragEnd = (e: React.DragEvent<HTMLDivElement>) => {
    setIsDragging(false); // 恢复 UI 状态
  };

  return (
    <div
      // 开启 HTML5 拖拽能力
      draggable
      // 绑定事件
      onDragStart={handleDragStart}
      onDragEnd={handleDragEnd}
      // 动态样式：根据状态改变颜色
      style={{
        width: 100, height: 100,
        backgroundColor: isDragging ? '#ccc' : '#007bff',
        cursor: 'move', // 鼠标移动上去变成十字箭头
        transition: 'all 0.2s' // 增加一点平滑过渡
      }}
    >
      {isDragging ? 'Dragging...' : 'Drag Me'}
    </div>
  );
};
```

---

## 3. 交互实战：富文本与剪贴板 (Clipboard)

React 甚至能拦截复制粘贴，这对于做富文本编辑器很有用。

### 3.1 `contentEditable` 与事件

```tsx
const RichEditor = () => {
  // 拦截粘贴事件
  const handlePaste = (e: React.ClipboardEvent) => {
    // 阻止浏览器直接把内容粘贴进去（防止产生乱七八糟的 HTML 标签）
    // 如果你注释掉这一行，富文本（比如红色的字）就会带样式粘贴进去
    e.preventDefault();

    // 只获取纯文本
    const text = e.clipboardData.getData('text/plain');
    console.log('用户粘贴了:', text);
    
    // ... 这里通常会手动把文本插入到光标位置（比较复杂，需配合 Selection API）
  };
  
  // 拦截复制事件
  const handleCopy = (e: React.ClipboardEvent) => {
    console.log('用户触发了复制');
    // 你可以在这里修改剪贴板的内容
    // e.clipboardData.setData('text/plain', '版权所有！');
    // e.preventDefault();
  }

  return (
    <div
      // 让 div 变成可编辑区域，像 textarea 一样
      contentEditable
      // 这里的 suppressContentEditableWarning 是为了消除 React 的一个警告
      // 因为 React 此时很难控制这个 div 内部的具体 HTML 变化
      suppressContentEditableWarning
      
      onPaste={handlePaste}
      onCopy={handleCopy}
      
      style={{
        border: '1px solid black',
        minHeight: '100px',
        padding: '10px'
      }}
    >
      试着复制这行<b>加粗的文字</b>，然后粘贴回来看看。
    </div>
  );
};
```

---

## 4. 总结

1.  **合成事件**：React 包了一层，为了兼容和性能。`onClick` 并不是直接绑在 DOM 上。
2.  **交互模式**：数据驱动 UI。拖拽时，我们只是修改了 `isDragging` 状态，React 负责把背景色变灰。你需要时刻保持 **“状态驱动”** 的思维。
