# 05 列表渲染与表单 (深度解析版)

## 0. 语法预热 (Prerequisites)

### 0.1 数组 map 方法
`map` 是 React 渲染列表的**唯一真神**。
*   它接受一个函数，将数组中的每一项“映射”成新的一项，返回新数组。
*   **注意**: `map` 不会修改原数组。

```javascript
const nums = [1, 2, 3];
// item => item * 2 是箭头函数
const doubled = nums.map(item => item * 2); // [2, 4, 6]
```

### 0.4 语法扫盲：Map vs ForEach
**一定要用 Map！**
*   `forEach`: 只是为了“遍历做事”（比如打印日志），它**没有返回值**（return undefined）。你不能把结果赋给变量。
*   `map`: 为了“加工生产”，它会返回一个新的数组。React 需要拿到这个新数组去渲染，所以必须用 map。

### 0.2 逻辑与 `&&` (Short-circuit evaluation)
React 中常用 `condition && <Component />` 来做条件渲染。
*   如果 `condition` 为真，返回 `<Component />`。
*   如果 `condition` 为假，返回假，React 忽略它，不渲染任何东西。

### 0.3 展开运算符 (Spread Operator) `...`
用于复制对象或数组。

```javascript
const oldObj = { a: 1, b: 2 };
const newObj = { ...oldObj, c: 3 }; // { a: 1, b: 2, c: 3 }
// 注意：这只是浅拷贝 (Shallow Copy)
```

---

## 1. 列表渲染 (List Rendering)

React 也可以像写普通 JS 一样渲染列表。

### 1.1 为什么必须要有 `key`？(面试必问)
当列表发生变化（比如中间插入了一项），React 需要知道：
*   哪些元素是新的？
*   哪些是旧的需要移动位置？
*   哪些删除了？

`key` 就是元素的**身份证**。
**如果只用 index 做 key**：如果数组顺序变了（比如 `[A, B]` 变成了 `[C, A, B]`），React 会认为第一个元素 `A` 变成了 `C`，它会直接原地修改这个 DOM 节点，而不是把 `C` 插入到 `A` 前面。这会导致严重的性能问题，甚至是 Bug（比如输入框内容错乱）。

### 1.2 代码逐行解析

```tsx
import React from 'react';

interface User {
  id: number;
  name: string;
}

const UserList = () => {
  // 模拟数据
  const users: User[] = [
    { id: 101, name: 'Alice' },
    { id: 102, name: 'Bob' },
  ];

  return (
    <ul>
      {/* 在 JSX 中使用 {} 插入 JS 表达式 */}
      {/* 使用 map 遍历 users 数组 */}
      {users.map((user) => {
        // 返回一个 JSX 元素
        return (
          // key 属性：必须加在最外层元素上，且必须唯一（推荐用 id，别用 index）
          <li key={user.id}>
            {user.name}
          </li>
        );
      })}
    </ul>
  );
};
```

### 1.3 进阶实战：多层级（嵌套）列表渲染
当你的数据结构是“数组套数组”时（比如：菜单 -> 子菜单），你需要**嵌套 Map**。

```tsx
interface Category {
  id: string;
  title: string;
  items: string[]; // 字符串数组
}

const Menu = () => {
  const categories: Category[] = [
    { id: 'fruit', title: '水果', items: ['Apple', 'Banana'] },
    { id: 'veg', title: '蔬菜', items: ['Carrot', 'Tomato'] },
  ];

  return (
    <div>
      {/* 第一层 Map: 渲染分类 */}
      {categories.map((cat) => (
        <div key={cat.id} style={{ marginBottom: 20 }}>
          <h3>{cat.title}</h3>
          <ul>
            {/* 第二层 Map: 渲染该分类下的 item */}
            {cat.items.map((item, index) => (
              // 这里的 key 只要在当前的 map 里唯一即可
              // 如果 item 字符串本身唯一，可以直接用 item 做 key
              <li key={item}>{item}</li>
            ))}
          </ul>
        </div>
      ))}
    </div>
  );
};
```
---

## 2. 表单：受控组件 (Controlled Component)

HTML 的表单元素（`<input>`, `<select>`）本身就维护着自己的状态。而在 React 中，我们通常要把这个“权利”收回来，让 React 的 `state` 成为**唯一数据源 (Single Source of Truth)**。

### 2.1 受控组件流程解析
1.  **State -> Input**: 设置 `value={state}`。如果不传 `onChange`，输入框就锁死了（只读）。
2.  **User Types**: 用户打字。
3.  **Input -> Event**: 触发 `onChange` 事件。
4.  **Handler -> State**: 我们在事件处理函数里调用 `setState(e.target.value)`。
5.  **Re-render**: 组件重绘，`input` 显示新的 `state` 值。

这就是所谓的**双向绑定**（在 React 中通过“单向数据流”+“事件回调”模拟实现）。

### 2.2 代码逐行解析

```tsx
import React, { useState } from 'react';

const SimpleInput = () => {
  // 定义状态，初始为空字符串
  const [text, setText] = useState('');

  // 事件处理函数
  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    // 1. 拿到用户输入的新值
    const newValue = e.target.value;
    
    // 2. 可以在这里做拦防（比如只允许输入大写字母）
    // setText(newValue.toUpperCase());
    
    // 3. 更新状态
    setText(newValue);
  };

  return (
    <div>
      {/* value 绑定 state，强制显示为 state 的值 */}
      <input type="text" value={text} onChange={handleChange} />
      
      <p>你输入的内容是: {text}</p>
    </div>
  );
};
```

---

## 3. 表单组件设计规范 (SOP)

如果你在封装一个组件库，请务必遵守规范：**All input components should have `value` and `onChange` props.**

```tsx
// 你的组件 Props
interface MyInputProps {
  value: string;
  onChange: (newValue: string) => void; // 这里的回调通常直接传值，而不是传 event
}

const MyInput: React.FC<MyInputProps> = (props) => {
  return (
    <input 
      value={props.value}
      // 内部把 event 消化掉，只把外部关心的 value 传出去
      // 这样父组件用起来更干净：onChange={val => setState(val)}
      onChange={(e) => props.onChange(e.target.value)} 
      style={{ border: '2px solid blue' }}
    />
  );
}
```

## 4. 总结
1.  **Key**: 不要用 index，除非列表永远不排序、不增删。
2.  **受控组件**: 把 `<input>` 当做一个纯粹的 UI，它的值完全由你控制。它没有自己的脾气，你让它显示啥它就显示啥。
