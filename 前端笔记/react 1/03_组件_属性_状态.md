# 03 组件、属性(Props)与状态(State) (深度解析版)

## 0. 语法预热 (Prerequisites)

### 0.1 TypeScript 接口 (Interface) 与泛型 (Generics)
在 React 中，我们用 `interface` 来描述一个对象长什么样，用 `<>` 来传递类型参数。

```typescript
// 1. 定义形状
interface User {
  name: string; // 必须有 name，且是字符串
  age?: number; // ? 表示可选，可以有 age 也可以没有
}

// 2. 泛型：你可以把它理解为类型的"参数"
// 这里的 T 是一个占位符，相当于函数的参数
function identity<T>(arg: T): T {
  return arg;
}
// 使用时传入具体类型
identity<string>("hello"); // T 变成了 string
```

### 0.2 解构赋值 (Destructuring)
快速从对象提取属性。

```javascript
const user = { name: "Alice", id: 1 };
// 传统写法
const name = user.name;
// 解构写法 (React中最常用)
const { name, id } = user;
```

### 0.3 类 (Class) 语法扫盲：`this` 与 `super`
*   **`this`**: 在 JS 类中，`this` 指向当前实例。但在 React 中，如果你直接把 `this.handleClick` 传给 onClick，`this` 会丢失（变成 undefined）。
    *   *解决方法*: 使用箭头函数 `handleClick = () => {}`，它会自动绑定 `this`。
*   **`super`**: 子类必须在构造函数 `constructor` 里第一行调用 `super()`，否则拿不到 `this`。
    *   `super(props)`: 只有传了 props，你才能在构造函数里用 `this.props`。虽然 React 16.3+ 以后大多情况不传也可以，但为了规范还是建议写上。

---

## 1. 组件化：React 的积木

组件分为两种：**类组件 (Class)** 和 **函数组件 (Function)**。
*   **类组件**：面向对象思想 (OOP)，有 `this`，有生命周期。
*   **函数组件**：函数式编程思想 (FP)，无 `this`，轻量，**是现在的绝对主流**。

---

## 2. 类组件 (Class Component) 与生命周期

虽然现在新项目很少写 Class 组件，但**理解它对于理解 React 的工作原理至关重要**，而且面试必问。

### 2.1 完整生命周期详解

React 组件的生命周期就像人的一生：出生 (Mount) -> 成长变化 (Update) -> 死亡 (Unmount)。

1.  **挂载阶段 (Mounting)**: 组件被放入 DOM。
    *   `constructor()`: 初始化 state，绑定 methods。
    *   `static getDerivedStateFromProps()`: 不常用，即使 props 变了来更新 state。
    *   `render()`: **必须**。计算 UI。
    *   **`componentDidMount()`**: **常用**。组件**已经**出现在屏幕上了。适合发网络请求、订阅事件、操作真实 DOM。

2.  **更新阶段 (Updating)**: props 或 state 变了。
    *   `static getDerivedStateFromProps()`
    *   `shouldComponentUpdate()`: **性能优化**。返回 false 阻止更新。
    *   `render()`
    *   `getSnapshotBeforeUpdate()`: 获取更新前的 DOM 状态（比如滚动条位置）。
    *   **`componentDidUpdate()`**: **常用**。更新完成了。适合根据新的 props 发请求。

3.  **卸载阶段 (Unmounting)**: 组件被移除。
    *   **`componentWillUnmount()`**: **常用**。清理战场（取消定时器、取消订阅）。

4.  **错误处理 (Error Handling)**:
    *   `static getDerivedStateFromError()`: 渲染备用 UI（降级 UI）。
    *   `componentDidCatch()`: 记录错误日志。

### 2.3 进阶实战：错误边界 (Error Boundary)
React 16 引入的概念。如果一个组件树中的某一个组件报错了，不应该导致整个 App 白屏崩溃，而应该只显示那一小块为“出错了”。
**注意：错误边界目前只能用类组件实现。**

```tsx
interface ErrorState { hasError: boolean; }

class ErrorBoundary extends React.Component<{children: React.ReactNode}, ErrorState> {
  state = { hasError: false };

  // 1. 捕获错误，更新 State，以便下一次渲染出备用 UI
  static getDerivedStateFromError(error: any) {
    return { hasError: true };
  }

  // 2. 记录错误日志 (比如发送给 Sentry)
  componentDidCatch(error: any, info: any) {
    console.error("Uncaught error:", error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}

// 使用方法：包裹可能报错的组件
// <ErrorBoundary> <MyWidget /> </ErrorBoundary>
```

### 2.2 类组件代码逐行解析

```tsx
import React from 'react';

// 定义 Props 类型
interface Props {
  name: string;
}
// 定义 State 类型
interface State {
  count: number;
}

// 类组件继承自 React.Component
// <Props, State> 是泛型，告诉 TS 这个组件的 props 和 state 长什么样
export class Counter extends React.Component<Props, State> {
  
  // 构造函数：初始化的地方
  constructor(props: Props) {
    super(props); // 必须调用 super，否则拿不到 this.props
    // 初始化 State 对象
    // State 是私有的，完全由组件自己控制
    this.state = {
      count: 0
    };
  }

  // 生命周期：组件挂载即刻触发
  componentDidMount() {
    console.log('Component Mounted!');
  }

  // 方法：使用箭头函数自动绑定 this
  handleClick = () => {
    // 【重要】不能直接修改 this.state.count = 1
    // 必须使用 setState 通知 React 数据变了
    this.setState({
      count: this.state.count + 1
    });
  }

  render() {
    // 从 this.state 解构出 count
    const { count } = this.state;
    // 从 this.props 解构出 name
    const { name } = this.props;

    return (
      <div onClick={this.handleClick}>
        <h1>Hello, {name}</h1>
        <p>Current Count: {count}</p>
      </div>
    );
  }
}
```

---

## 3. 函数组件 (Function Component) 与 Props

这是现代 React 的写法。没有 `this`，没有复杂的生命周期方法，只有 Hooks。

### 3.1 属性 (Props)

**Props 是什么？**
*   它是父组件传递给子组件的数据（就像函数的参数）。
*   **Props 是只读的 (Immutable)**：子组件绝对不能修改 Props。如果你想改，必须请求父组件改。

### 3.2 状态 (State) - useState Hook

**State 是什么？**
*   它是组件内部自己管理的数据（就像函数的局部变量，但是具有“记忆”能力）。

```tsx
import React, { useState } from 'react';

interface Props {
  initialCount?: number; // 可选属性
}

// React.FC 是 Functional Component 的缩写
const CounterFC: React.FC<Props> = ({ initialCount = 0 }) => {
  // 解构 props，并给 initialCount 设置默认值 0

  // useState Hook 详解：
  // 参数 (0): 状态的初始值。只有第一次渲染有效。
  // 返回值 [count, setCount]: 数组解构。
  //    count: 当前的状态值 (比如 0)。
  //    setCount: 一个函数，用来更新状态。
  const [count, setCount] = useState<number>(initialCount);

  const increment = () => {
    // 为什么用回调函数 prev => prev + 1 ？
    // 因为 setCount 是异步的（批处理）。
    // 如果你依赖旧值计算新值，回调写法最安全，能保证 prev 是最新的。
    setCount((prev) => prev + 1);
  };

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>+</button>
    </div>
  );
};
```

### 3.3 核心对比：Class vs Function

| 维度 | Class Component | Function Component |
| :--- | :--- | :--- |
| **思维模型** | **面向对象** (Instance) | **函数式** (Closure/Snapshot) |
| **状态持有** | `this.state` (一直是同一个引用) | `useState` (每次渲染都是新变量) |
| **生命周期** | 具体的方法 (`didMount` 等) | `useEffect` (副作用的集合) |
| **代码量** | 较多 (样板代码多) | **精简** |
| **未来趋势** | 维护模式 | **绝对主流** |

---

## 4. 总结

1.  **组件**是 UI 的单元，**Props** 是输入，**State** 是内部状态。
2.  **UI = f(state)** 中，Props 和 State 的变化都会触发 `f` 重新运行（Re-render）。
3.  **单向数据流**：数据只能从父流向子（Props），子不能直接改父的数据（除非父给子一个回调函数）。
